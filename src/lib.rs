//! Driver for a PS/2 keyboard.
//!
//! Supports PS/2 Scan Code Set 1 and 2, on both UK and UK English keyboards. See [the
//! OSDev Wiki](https://wiki.osdev.org/PS/2_Keyboard).
//!
//! Requires that you sample a pin in an interrupt routine and shift in the
//! bit. We don't sample the pin in this library, as that makes testing
//! difficult, and it means you have to make this object a global static mut
//! that the interrupt can access, which is unsafe.

#![feature(const_fn_trait_bound)]
#![cfg_attr(not(test), no_std)]
#[cfg(test)]
extern crate std as core;

// ****************************************************************************
//
// Imports
//
// ****************************************************************************

use core::marker::PhantomData;

// ****************************************************************************
//
// Modules
//
// ****************************************************************************

mod scancodes;
pub use crate::scancodes::{ScancodeSet1, ScancodeSet2};

// ****************************************************************************
//
// Public Types
//
// ****************************************************************************

/// `Keyboard<T, S>` encapsulates decode/sampling logic, and handles state transitions and key events.
/// Size: 10 bytes
#[derive(Debug)]
pub struct Keyboard<T, S>
where
    T: KeyboardLayout,
    S: ScancodeSet,
{
    register: u16,
    num_bits: u8,
    decode_state: DecodeState,
    handle_ctrl: HandleControl,
    modifiers: Modifiers,
    _layout: PhantomData<T>,
    _set: PhantomData<S>,
}

/// Indicates different error conditions.
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum Error {
    BadStartBit,
    BadStopBit,
    ParityError,
    UnknownKeyCode,
    #[doc(hidden)]
    InvalidState,
}

/// Keycodes that can be generated by a keyboard.
#[derive(Debug, PartialEq, Eq, Copy, Clone, PartialOrd, Ord)]
#[non_exhaustive]
pub enum KeyCode {
    AltLeft = 0,
    AltRight = 1,
    ArrowDown = 2,
    ArrowLeft = 3,
    ArrowRight = 4,
    ArrowUp = 5,
    BackSlash = 6,
    Backspace = 7,
    BackTick = 8,
    BracketSquareLeft = 9,
    BracketSquareRight = 10,
    Break = 11,
    CapsLock = 12,
    Comma = 13,
    ControlLeft = 14,
    ControlRight = 15,
    Delete = 16,
    End = 17,
    Enter = 18,
    Escape = 19,
    Equals = 20,
    F1 = 21,
    F2 = 22,
    F3 = 23,
    F4 = 24,
    F5 = 26,
    F6 = 27,
    F7 = 28,
    F8 = 29,
    F9 = 30,
    F10 = 31,
    F11 = 32,
    F12 = 33,
    Fullstop = 34,
    Home = 36,
    Insert = 37,
    Key1 = 38,
    Key2 = 39,
    Key3 = 40,
    Key4 = 41,
    Key5 = 42,
    Key6 = 43,
    Key7 = 44,
    Key8 = 46,
    Key9 = 47,
    Key0 = 48,
    Menus = 49,
    Minus = 50,
    Numpad0 = 51,
    Numpad1 = 52,
    Numpad2 = 53,
    Numpad3 = 54,
    Numpad4 = 56,
    Numpad5 = 57,
    Numpad6 = 58,
    Numpad7 = 59,
    Numpad8 = 60,
    Numpad9 = 61,
    NumpadEnter = 62,
    NumpadLock = 63,
    NumpadSlash = 64,
    NumpadStar = 66,
    NumpadMinus = 67,
    NumpadPeriod = 68,
    NumpadPlus = 69,
    PageDown = 70,
    PageUp = 71,
    PauseBreak = 72,
    PrintScreen = 73,
    ScrollLock = 74,
    SemiColon = 76,
    ShiftLeft = 77,
    ShiftRight = 78,
    Slash = 79,
    Spacebar = 80,
    SysReq = 81,
    Tab = 82,
    Quote = 83,
    WindowsLeft = 84,
    WindowsRight = 86,
    A = 87,
    B = 88,
    C = 89,
    D = 90,
    E = 91,
    F = 92,
    G = 93,
    H = 94,
    I = 96,
    J = 97,
    K = 98,
    L = 99,
    M = 100,
    N = 101,
    O = 102,
    P = 103,
    Q = 104,
    R = 106,
    S = 107,
    T = 108,
    U = 109,
    V = 110,
    W = 111,
    X = 112,
    Y = 113,
    Z = 114,
    /// The key to the left of the 102/105-key "Tall Return" Key - not on 101/104-key keyboards
    HashTilde = 115,
    // Scan code set 1 unique codes
    PrevTrack = 116,
    NextTrack = 117,
    Mute = 118,
    Calculator = 119,
    Play = 120,
    Stop = 121,
    VolumeDown = 122,
    VolumeUp = 123,
    WWWHome = 124,
    /// Sent when the keyboard boots
    PowerOnTestOk = 125,
    /// Used for `<>` on DE layouts
    Oem102 = 126,
    /// PrintScreen comes in two parts - this is the second
    PrintScreen2 = 127,
    /// Sent by the keyboard when too many keys are pressed
    TooManyKeys = 128,
}

#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum KeyState {
    Up,
    Down,
    SingleShot,
}

/// Options for how we can handle what happens when the Ctrl key is held down
/// and a letter is pressed.
#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum HandleControl {
    /// If either Ctrl key is held down, convert the letters A through Z into
    /// Unicode chars U+0001 through U+001A. If the Ctrl keys are not held
    /// down, letters go through normally.
    MapLettersToUnicode,
    /// Don't do anything special - send through the Ctrl key up/down events,
    /// and leave the letters as letters.
    Ignore,
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct KeyEvent {
    pub code: KeyCode,
    pub state: KeyState,
}

pub trait KeyboardLayout {
    /// Convert a `KeyCode` enum to a Unicode character, if possible.
    /// `KeyCode::A` maps to `Some('a')` (or `Some('A')` if shifted), while
    /// `KeyCode::AltLeft` returns `None`
    fn map_keycode(
        keycode: KeyCode,
        modifiers: &Modifiers,
        handle_ctrl: HandleControl,
    ) -> DecodedKey;
}

pub trait ScancodeSet {
    /// Handles the state logic for the decoding of scan codes into key events.
    fn advance_state(state: &mut DecodeState, code: u8) -> Result<Option<KeyEvent>, Error>;

    /// Convert a Scan Code set X byte to our 'KeyCode' enum
    fn map_scancode(code: u8) -> Result<KeyCode, Error>;

    /// Convert a Scan Code Set X extended byte (prefixed E0) to our `KeyCode`
    /// enum.
    fn map_extended_scancode(code: u8) -> Result<KeyCode, Error>;

    /// Convert a Scan Code Set X extended byte (prefixed E1) to our `KeyCode`
    /// enum.
    fn map_extended2_scancode(code: u8) -> Result<KeyCode, Error>;
}

#[derive(Debug)]
pub struct Modifiers {
    pub lshift: bool,
    pub rshift: bool,
    pub lctrl: bool,
    pub rctrl: bool,
    pub numlock: bool,
    pub capslock: bool,
    pub alt_gr: bool,
}

#[derive(Debug, PartialEq, Eq, Copy, Clone)]
pub enum DecodedKey {
    RawKey(KeyCode),
    Unicode(char),
}

// ****************************************************************************
//
// Public Data
//
// ****************************************************************************

// None

// ****************************************************************************
//
// Private Types
//
// ****************************************************************************

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum DecodeState {
    Start,
    Extended,
    Release,
    ExtendedRelease,
    Extended2,
    Extended2Release,
}

// ****************************************************************************
//
// Private Data
//
// ****************************************************************************

const KEYCODE_BITS: u8 = 11;
const EXTENDED_KEY_CODE: u8 = 0xE0;
const EXTENDED2_KEY_CODE: u8 = 0xE1;
const KEY_RELEASE_CODE: u8 = 0xF0;

// ****************************************************************************
//
// Public Functions and Implementation
//
// ****************************************************************************

impl<T, S> Keyboard<T, S>
where
    T: KeyboardLayout,
    S: ScancodeSet,
{
    /// Make a new Keyboard object with the given layout.
    pub const fn new(handle_ctrl: HandleControl) -> Keyboard<T, S> {
        Keyboard {
            register: 0,
            num_bits: 0,
            decode_state: DecodeState::Start,
            handle_ctrl,
            modifiers: Modifiers {
                lshift: false,
                rshift: false,
                lctrl: false,
                rctrl: false,
                numlock: true,
                capslock: false,
                alt_gr: false,
            },
            _layout: PhantomData,
            _set: PhantomData,
        }
    }

    /// Change the Ctrl key mapping.
    pub fn set_ctrl_handling(&mut self, new_value: HandleControl) {
        self.handle_ctrl = new_value;
    }

    /// Get the current Ctrl key mapping.
    pub const fn get_ctrl_handling(&self) -> HandleControl {
        self.handle_ctrl
    }

    /// Clears the bit register.
    ///
    /// Call this when there is a timeout reading data from the keyboard.
    pub fn clear(&mut self) {
        self.register = 0;
        self.num_bits = 0;
        self.decode_state = DecodeState::Start;
    }

    /// Processes a 16-bit word from the keyboard.
    ///
    /// * The start bit (0) must be in bit 0.
    /// * The data octet must be in bits 1..8, with the LSB in bit 1 and the
    ///   MSB in bit 8.
    /// * The parity bit must be in bit 9.
    /// * The stop bit (1) must be in bit 10.
    pub fn add_word(&mut self, word: u16) -> Result<Option<KeyEvent>, Error> {
        let byte = Self::check_word(word)?;
        self.add_byte(byte)
    }

    /// Processes an 8-bit byte from the keyboard.
    ///
    /// We assume the start, stop and parity bits have been processed and
    /// verified.
    pub fn add_byte(&mut self, byte: u8) -> Result<Option<KeyEvent>, Error> {
        S::advance_state(&mut self.decode_state, byte)
    }

    /// Shift a bit into the register.
    ///
    /// Call this /or/ call `add_word` - don't call both.
    /// Until the last bit is added you get Ok(None) returned.
    pub fn add_bit(&mut self, bit: bool) -> Result<Option<KeyEvent>, Error> {
        self.register |= (bit as u16) << self.num_bits;
        self.num_bits += 1;
        if self.num_bits == KEYCODE_BITS {
            let word = self.register;
            self.register = 0;
            self.num_bits = 0;
            self.add_word(word)
        } else {
            Ok(None)
        }
    }

    /// Processes a `KeyEvent` returned from `add_bit`, `add_byte` or `add_word`
    /// and produces a decoded key.
    ///
    /// For example, the KeyEvent for pressing the '5' key on your keyboard
    /// gives a DecodedKey of unicode character '5', unless the shift key is
    /// held in which case you get the unicode character '%'.
    pub fn process_keyevent(&mut self, ev: KeyEvent) -> Option<DecodedKey> {
        match ev {
            KeyEvent {
                code: KeyCode::ShiftLeft,
                state: KeyState::Down,
            } => {
                self.modifiers.lshift = true;
                None
            }
            KeyEvent {
                code: KeyCode::ShiftRight,
                state: KeyState::Down,
            } => {
                self.modifiers.rshift = true;
                None
            }
            KeyEvent {
                code: KeyCode::ShiftLeft,
                state: KeyState::Up,
            } => {
                self.modifiers.lshift = false;
                None
            }
            KeyEvent {
                code: KeyCode::ShiftRight,
                state: KeyState::Up,
            } => {
                self.modifiers.rshift = false;
                None
            }
            KeyEvent {
                code: KeyCode::CapsLock,
                state: KeyState::Down,
            } => {
                self.modifiers.capslock = !self.modifiers.capslock;
                None
            }
            KeyEvent {
                code: KeyCode::NumpadLock,
                state: KeyState::Down,
            } => {
                self.modifiers.numlock = !self.modifiers.numlock;
                None
            }
            KeyEvent {
                code: KeyCode::ControlLeft,
                state: KeyState::Down,
            } => {
                self.modifiers.lctrl = true;
                None
            }
            KeyEvent {
                code: KeyCode::ControlLeft,
                state: KeyState::Up,
            } => {
                self.modifiers.lctrl = false;
                None
            }
            KeyEvent {
                code: KeyCode::ControlRight,
                state: KeyState::Down,
            } => {
                self.modifiers.rctrl = true;
                None
            }
            KeyEvent {
                code: KeyCode::ControlRight,
                state: KeyState::Up,
            } => {
                self.modifiers.rctrl = false;
                None
            }
            KeyEvent {
                code: KeyCode::AltRight,
                state: KeyState::Down,
            } => {
                self.modifiers.alt_gr = true;
                None
            }
            KeyEvent {
                code: KeyCode::AltRight,
                state: KeyState::Up,
            } => {
                self.modifiers.alt_gr = false;
                None
            }
            KeyEvent {
                code: c,
                state: KeyState::Down,
            } => Some(T::map_keycode(c, &self.modifiers, self.handle_ctrl)),
            _ => None,
        }
    }

    const fn get_bit(word: u16, offset: usize) -> bool {
        ((word >> offset) & 0x0001) != 0
    }

    const fn has_even_number_bits(data: u8) -> bool {
        (data.count_ones() % 2) == 0
    }

    /// Check 11-bit word has 1 start bit, 1 stop bit and an odd parity bit.
    const fn check_word(word: u16) -> Result<u8, Error> {
        let start_bit = Self::get_bit(word, 0);
        let parity_bit = Self::get_bit(word, 9);
        let stop_bit = Self::get_bit(word, 10);
        let data = ((word >> 1) & 0xFF) as u8;

        if start_bit {
            return Err(Error::BadStartBit);
        }

        if !stop_bit {
            return Err(Error::BadStopBit);
        }

        let need_parity = Self::has_even_number_bits(data);

        // Odd parity, so these must not match
        if need_parity != parity_bit {
            return Err(Error::ParityError);
        }

        Ok(data)
    }
}

impl KeyEvent {
    pub const fn new(code: KeyCode, state: KeyState) -> KeyEvent {
        KeyEvent { code, state }
    }
}

// ****************************************************************************
//
// Keyboard Layouts
//
// ****************************************************************************

impl Modifiers {
    pub const fn is_shifted(&self) -> bool {
        self.lshift | self.rshift
    }

    pub const fn is_ctrl(&self) -> bool {
        self.lctrl | self.rctrl
    }

    pub const fn is_caps(&self) -> bool {
        (self.lshift | self.rshift) ^ self.capslock
    }
}

pub mod layouts;

// ****************************************************************************
//
// Tests
//
// ****************************************************************************

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_f9() {
        let mut k =
            Keyboard::<layouts::Us104Key, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);
        // start
        assert_eq!(k.add_bit(false), Ok(None));
        // 8 data bits (LSB first)
        assert_eq!(k.add_bit(true), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        // parity
        assert_eq!(k.add_bit(false), Ok(None));
        // stop
        assert_eq!(
            k.add_bit(true),
            Ok(Some(KeyEvent::new(KeyCode::F9, KeyState::Down)))
        );
    }

    #[test]
    fn test_f9_word() {
        let mut k =
            Keyboard::<layouts::Us104Key, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);
        assert_eq!(
            k.add_word(0x0402),
            Ok(Some(KeyEvent::new(KeyCode::F9, KeyState::Down)))
        );
    }

    #[test]
    fn test_f9_byte() {
        let mut k =
            Keyboard::<layouts::Us104Key, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);
        assert_eq!(
            k.add_byte(0x01),
            Ok(Some(KeyEvent::new(KeyCode::F9, KeyState::Down)))
        );
    }

    #[test]
    fn test_keyup_keydown() {
        let mut k =
            Keyboard::<layouts::Us104Key, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);
        assert_eq!(
            k.add_byte(0x01),
            Ok(Some(KeyEvent::new(KeyCode::F9, KeyState::Down)))
        );
        assert_eq!(
            k.add_byte(0x01),
            Ok(Some(KeyEvent::new(KeyCode::F9, KeyState::Down)))
        );
        assert_eq!(k.add_byte(0xF0), Ok(None));
        assert_eq!(
            k.add_byte(0x01),
            Ok(Some(KeyEvent::new(KeyCode::F9, KeyState::Up)))
        );
    }

    #[test]
    fn test_f5() {
        let mut k =
            Keyboard::<layouts::Us104Key, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);
        // start
        assert_eq!(k.add_bit(false), Ok(None));
        // 8 data bits (LSB first)
        assert_eq!(k.add_bit(true), Ok(None));
        assert_eq!(k.add_bit(true), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        // parity
        assert_eq!(k.add_bit(true), Ok(None));
        // stop
        assert_eq!(
            k.add_bit(true),
            Ok(Some(KeyEvent::new(KeyCode::F5, KeyState::Down)))
        );
    }

    #[test]
    fn test_f5_up() {
        let mut k =
            Keyboard::<layouts::Us104Key, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);
        // Send F0

        // start
        assert_eq!(k.add_bit(false), Ok(None));
        // 8 data bits (LSB first)
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(true), Ok(None));
        assert_eq!(k.add_bit(true), Ok(None));
        assert_eq!(k.add_bit(true), Ok(None));
        assert_eq!(k.add_bit(true), Ok(None));
        // parity
        assert_eq!(k.add_bit(true), Ok(None));
        // stop
        assert_eq!(k.add_bit(true), Ok(None));

        // Send 03

        // start
        assert_eq!(k.add_bit(false), Ok(None));
        // 8 data bits (LSB first)
        assert_eq!(k.add_bit(true), Ok(None));
        assert_eq!(k.add_bit(true), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        assert_eq!(k.add_bit(false), Ok(None));
        // parity
        assert_eq!(k.add_bit(true), Ok(None));
        // stop
        assert_eq!(
            k.add_bit(true),
            Ok(Some(KeyEvent::new(KeyCode::F5, KeyState::Up)))
        );
    }

    #[test]
    fn test_shift() {
        let mut k =
            Keyboard::<layouts::Uk105Key, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);
        // A with left shift held
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::ShiftLeft, KeyState::Down)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Down)),
            Some(DecodedKey::Unicode('A'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Up)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::ShiftLeft, KeyState::Up)),
            None
        );

        // A with no shift
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Down)),
            Some(DecodedKey::Unicode('a'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Up)),
            None
        );

        // A with right shift held
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::ShiftRight, KeyState::Down)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Down)),
            Some(DecodedKey::Unicode('A'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Up)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::ShiftRight, KeyState::Up)),
            None
        );

        // Caps lock ON
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::CapsLock, KeyState::Down)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::CapsLock, KeyState::Up)),
            None
        );

        // Letters are now caps
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::X, KeyState::Down)),
            Some(DecodedKey::Unicode('X'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::X, KeyState::Up)),
            None
        );

        // Unless you press shift
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::ShiftRight, KeyState::Down)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Down)),
            Some(DecodedKey::Unicode('a'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Up)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::ShiftRight, KeyState::Up)),
            None
        );

        // Numbers are not shifted
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::Key1, KeyState::Down)),
            Some(DecodedKey::Unicode('1'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::Key1, KeyState::Up)),
            None
        );
    }

    #[test]
    fn test_ctrl() {
        let mut k =
            Keyboard::<layouts::Us104Key, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);
        // Normal
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Down)),
            Some(DecodedKey::Unicode('a'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Up)),
            None
        );
        // Left Control
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::ControlLeft, KeyState::Down)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Down)),
            Some(DecodedKey::Unicode('\u{0001}'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::ControlLeft, KeyState::Up)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Up)),
            None
        );
        // Normal
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Down)),
            Some(DecodedKey::Unicode('a'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Up)),
            None
        );
        // Right Control
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::ControlRight, KeyState::Down)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Down)),
            Some(DecodedKey::Unicode('\u{0001}'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::ControlRight, KeyState::Up)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Up)),
            None
        );
    }

    #[test]
    fn test_numlock() {
        let mut k =
            Keyboard::<layouts::Uk105Key, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);

        // Numlock ON by default
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::Numpad0, KeyState::Down)),
            Some(DecodedKey::Unicode('0'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::Numpad0, KeyState::Up)),
            None
        );

        // Numlock OFF
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::NumpadLock, KeyState::Down)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::NumpadLock, KeyState::Up)),
            None
        );

        // Now KP_0 produces INSERT
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::Numpad0, KeyState::Down)),
            Some(DecodedKey::RawKey(KeyCode::Insert))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::Numpad0, KeyState::Up)),
            None
        );
    }

    #[test]
    fn validate_scancodes() {
        let mut codes = Vec::new();
        let mut errs = Vec::new();
        for code in 0x00..=0x7F {
            let r = ScancodeSet1::map_scancode(code);
            match r {
                Ok(c) => codes.push(c),
                Err(_) => errs.push(code),
            }
        }
        codes.sort();
        println!("{:?}", codes);
        assert_eq!(codes.len(), 86);
        assert_eq!(errs.len(), 42);

        let mut codes = Vec::new();
        let mut errs = Vec::new();
        for code in 0x00..=0xFF {
            let r = ScancodeSet2::map_scancode(code);
            match r {
                Ok(c) => codes.push(c),
                Err(_) => errs.push(code),
            }
        }
        codes.sort();
        println!("{:?}", codes);
        assert_eq!(codes.len(), 89);
        assert_eq!(errs.len(), 167);
    }

    #[test]
    fn test_set_1_down_up_down() {
        let mut k =
            Keyboard::<layouts::Us104Key, ScancodeSet1>::new(HandleControl::MapLettersToUnicode);
        assert_eq!(
            k.add_byte(0x1e),
            Ok(Some(KeyEvent::new(KeyCode::A, KeyState::Down)))
        );
        assert_eq!(
            k.add_byte(0x9e),
            Ok(Some(KeyEvent::new(KeyCode::A, KeyState::Up)))
        );
        assert_eq!(
            k.add_byte(0x1f),
            Ok(Some(KeyEvent::new(KeyCode::S, KeyState::Down)))
        );
    }

    #[test]
    fn test_set_1_ext_down_up_down() {
        let mut k =
            Keyboard::<layouts::Us104Key, ScancodeSet1>::new(HandleControl::MapLettersToUnicode);
        assert_eq!(k.add_byte(0xe0), Ok(None));
        assert_eq!(
            k.add_byte(0x1c),
            Ok(Some(KeyEvent::new(KeyCode::NumpadEnter, KeyState::Down)))
        );
        assert_eq!(k.add_byte(0xe0), Ok(None));
        assert_eq!(
            k.add_byte(0x9c),
            Ok(Some(KeyEvent::new(KeyCode::NumpadEnter, KeyState::Up)))
        );
    }

    #[test]
    fn test_set_2_poweron() {
        let mut k =
            Keyboard::<layouts::Us104Key, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);
        assert_eq!(
            k.add_byte(0xAA),
            Ok(Some(KeyEvent::new(
                KeyCode::PowerOnTestOk,
                KeyState::SingleShot
            )))
        );
    }

    #[test]
    fn test_set_2_toomanykeys() {
        let mut k =
            Keyboard::<layouts::Us104Key, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);
        assert_eq!(
            k.add_byte(0x00),
            Ok(Some(KeyEvent::new(
                KeyCode::TooManyKeys,
                KeyState::SingleShot
            )))
        );
    }

    #[test]
    fn test_set_2_down_up() {
        let mut k =
            Keyboard::<layouts::Us104Key, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);
        assert_eq!(
            k.add_byte(0x29),
            Ok(Some(KeyEvent::new(KeyCode::Spacebar, KeyState::Down)))
        );
        assert_eq!(k.add_byte(0xF0), Ok(None));
        assert_eq!(
            k.add_byte(0x29),
            Ok(Some(KeyEvent::new(KeyCode::Spacebar, KeyState::Up)))
        );
        assert_eq!(
            k.add_byte(0x29),
            Ok(Some(KeyEvent::new(KeyCode::Spacebar, KeyState::Down)))
        );
        assert_eq!(k.add_byte(0xF0), Ok(None));
        assert_eq!(
            k.add_byte(0x29),
            Ok(Some(KeyEvent::new(KeyCode::Spacebar, KeyState::Up)))
        );
        assert_eq!(
            k.add_byte(0x29),
            Ok(Some(KeyEvent::new(KeyCode::Spacebar, KeyState::Down)))
        );
        assert_eq!(k.add_byte(0xF0), Ok(None));
        assert_eq!(
            k.add_byte(0x29),
            Ok(Some(KeyEvent::new(KeyCode::Spacebar, KeyState::Up)))
        );
    }

    #[test]
    fn test_set_2_ext_down_up() {
        let mut k =
            Keyboard::<layouts::Us104Key, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);
        assert_eq!(k.add_byte(0xE0), Ok(None));
        assert_eq!(
            k.add_byte(0x6C),
            Ok(Some(KeyEvent::new(KeyCode::Home, KeyState::Down)))
        );
        assert_eq!(k.add_byte(0xE0), Ok(None));
        assert_eq!(k.add_byte(0xF0), Ok(None));
        assert_eq!(
            k.add_byte(0x6C),
            Ok(Some(KeyEvent::new(KeyCode::Home, KeyState::Up)))
        );
    }

    #[test]
    fn test_frazert() {
        let mut k =
            Keyboard::<layouts::Azerty, ScancodeSet2>::new(HandleControl::MapLettersToUnicode);
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::NumpadSlash, KeyState::Down)),
            Some(DecodedKey::Unicode('/'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::NumpadStar, KeyState::Down)),
            Some(DecodedKey::Unicode('*'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::A, KeyState::Down)),
            Some(DecodedKey::Unicode('q'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::Key4, KeyState::Down)),
            Some(DecodedKey::Unicode('\''))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::BackSlash, KeyState::Down)),
            Some(DecodedKey::Unicode('*'))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::Numpad0, KeyState::Up)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::NumpadLock, KeyState::Down)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::NumpadLock, KeyState::Up)),
            None
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::Numpad0, KeyState::Down)),
            Some(DecodedKey::RawKey(KeyCode::Insert))
        );
        assert_eq!(
            k.process_keyevent(KeyEvent::new(KeyCode::Numpad0, KeyState::Up)),
            None
        );
    }
}

// ****************************************************************************
//
// End Of File
//
// ****************************************************************************
